Signature Replay Attack (Blockchain  && off-chain):

Using the same signature to execute multiple transactions multiple times.
How:
Same Address, same signature (1)
Same code, different address (2)

Prevention:
- (1) Using different phrase to sign each time + ***using a nounce in signature, cant use the same nounce 
- (2) Include address of contract in signature (unique) -> Admin send to fake website to enter -> will not be able
	to enter since the address will not be of the smart contract

Test:
Assume-> Admin knows the phrase to be signed,. After signing, admin copies the signature to perform attck

/////////////////////////////////////////////////////////////////
Voting Destruction attack: (off-chain)
Admin tries changing the starting voting with 1 or no voters

/////////////////////////////////////////////////////////
vOTER Registration Late Attack/Hack: (off-chain)

- User opens form during registration but submits the form late after to manipilate system, 
	or to cause a system failure, subbotage
	
/////////////////////////////////////////////////////////
Accessing Private Data (Blockchain):

Private means other contracts cannot access the variables.
However, just coz it s private doesnt mean the is no access to the data.

How:
The is a vulnerablity -> priavte state vars can BE READ. -> **********Encrypt data before arriving in Blockchain using AES *************
hOW EVM STORES STATE VARIBALES  
	-> Assume we have a contract with variables: bytes32 foo, bytes32 bar, uint num, address addr, bool boo.
		Stores each var in the data atrray of a contract with len=2**256 slots. Easch slot can store up to 32 bytes.
		Vars are stored in the order they are declred in.
		uints stored in hexidecimal -> 32 bytes
		**address stored in hex - stored in 20 bytes. Solidity then uses the left-over bytes to store another variable.
		**bool needs 1 byte, is stored with address
		
		public fixed array[3]-> slot 3, 4,5 stores elements, Slot 6 stores length of array
		
		for dynamic array -> length od array is stored in slot = keccak256(6), then the elements of the array are
		stored starting form the hash (keccak256(6)), eg struct (uint, bytes32 password) -> each element will take up 2
		slots. So element at index=0, is stored at hash+0, element at index=1 is stored at hash+2 slots-> so address slot is
		= keccak256(6) + index * elementSsize(= 2 slots)
		
		
		mapping(uint => struct) -. entries sre stored at keccak256(key, slot) -> next available slot is 7, key=map key (aka index)
		
		
		Getting private vars; truffle cli->
						addr = "smart contract" --> storing var
						get vars --> web3.eth.getStorageAt(addr, slot->0,console.log()) -> stored in hex
						bytes32 password can be converted into string using web3.utils.toAscii(hex)
						
						get the address slot - web3.utils.soliditySha3({type: "uint", value:6}). Then to get var stored at hash,
						perform same fucntion, to get second element of struct, increment hash by 1.
						
						Private data better not stored in un-encryption
						
						
		
Front Running (Blockchain):
	How transction occurs-> sender sends transction to miners, transaction gets relayed to other miners.
	Each miner keeps track of pending transctions in the transction pool (transactions that are yet to 
	be icluded in a block. After some time transction gets included in a block. 
	
	How attack works: While transction is still inside the transaction pool, attacker sends transction and is 
	also added to transaction pool with victim transaction. Assume miner picks victim + attacker transaction 
	to include in the next block. And attacker's transaction will be included first (attacker paid a higher gas price).
	Having a higher gas price allows the attacker to look into the (secret /data) of the other smarts contract (in pool).
	Attacker sends high gas price before victim, to perform the same function faster.

Solution:
insecure randomness (blockchain) -> added contract address to random function:
Guessing the vars used to create a random number -> keccak256(abi.encodedPack(num1, num2))
assuming vra used are block.timestamp, block.number. The vars are easily available to all smart contracts.
Attacker uses another smart contract to also call the same random function with same values. Eve attcker deploys 
their contract the same time. Block.number and Block.timestamp are the same in both blocks


Victim deploys first. Then attacker deploys

Hide Malicious Code (Blockchain):
	Hiding code the when contract is published.
	
Solution: 
Seperate file, ,malicious code is put.Use function in malicios contract instead of normal contract.

Prevention: 
If a contract is using an unverified address, might be malicios. address of contracts must be verifed.


Phishing with tx.origin attack (blockchain):
	Happens when an attacker disguiess an a verified user.
	tx.origin -> address of whwere the address was originated.
	
	How:
	only Owner/Admin can perform certain function. If attacker can trick owner to calling the Malicious 
	Contract -> which calls the function in the	function in the real contact, then the require function 
	will be verified even if the attacker is executing the function. 
	
	in Attacker code :
	 
	address owner_attacker; //addres that will gain
	Victim viction smart contract; //target
	 
	constructor(Wallet wallet) public{
		wallet = Wallet(_wallet)
		owner = msg.sender;
		
	}
	
	//trick victim to call function, that grabs the addres of the msg.sender -. which is the admin/owner
	// using the address captured, attacker calls function in victim contract using captured address.
	function attack() public{
	 wallet.transfer(owner(attacker(, allMoney); <--- called by victim
	}
	
Prevention: Use msg.sender instead of tx.origin. Msg.snder always points to the contract/address the called
	contract
	


HoneyPot -> Trap to catch hackers (Blockchain]: using Hide Malicious Code .
Comparing strings = hash strinsg and compare hashes. The failed transction will then reveal the addres of the 
attcker.


Contract with Zero Code: 
Assume a contract protects its self by not acceptinf addresses from contracts. This is done by checking the code size
at that address e.g:
uint size;
assembly{ 
	size:= extcodesize(account)
	}
	size>0
	
How: conract mus have code size of 0, however, when the attcker contract is being deployed at the same time
	as it is being called, the codesize will be zero. 
	
	So in constructor of the attacker, the victim contract (address ) is called to a execute a function. The victim
	contract will think the address calling it as a normal address, and execute function.
	
	
Different Contracts at same address (attacker):


Front-End **************
Links:
https://www.youtube.com/watch?v=QSMbk2nLTBk

Use sanitize to prevent attacks,

ms - regular expression dns -> block long input to prevent flooding


solutions:
tools: snyk

link:
https://www.youtube.com/watch?v=Ud5xKCYQTjM&list=TLPQMzAwOTIwMjO4ZIyXwAapPA&index=28


Places where data is passed to contract -> Reg Form ->

(Decryption) -> Get Users, 



------------------ANALYSIS----------------------------------------

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< VALIDATION ->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Admin can -> add users,
			-> start election, change phase, view results
			
User -> can register, can vote, can vote, view results and submit vote for audit


--------------------------- Attack anaylsis --------------------------------------------------------------------------------------------->

*************** (light weight) ************
Admin -> tries to start voting without candidates, ends voting voting with no votes, add candidate during voting. Sneefinng data sent by voters

User -> User tries the use the same re-register with the same personal-id, user tries to register with a different public key, user tries to ender admin overview.
		User tries to enter late


************** (heavyWeight) **************

 SQL INJECTIONS___ + Cross Script Attack + Regress Expression DNS  (OFF-CHAIN) + xss Attack (javascript injection)
 Assume user is malicious and tries to perform these attacks.
 Example;
	<img src onerror="alert('hi')"> ***************
	cAN ACCES DETAILS = > <img src onerror="alert(documebt.cookie)"> *************** or get session id
 
 
 Signature Replay Attack (Blockchain  && off-chain)
 Assume the voter who is malicious captures the signature of the Admin when signing in. The attcker willluse the same signature to enter contract
 while using a different address.
 
 
Front Running attack (blockchain)
 Since the private key of an ECC is an uint integer. The attacker may try to guess the private key of the user, since all all blockchain users have access to block.timestamp and block.number
 
Phishing with tx.origin attack (blockchain):
Assume an attacker convinces the admin to perform a function in their malicious contract in order to capture the address of the victim and use it enter the voting contract
as a verified user.
tx.origin -> address of whwere the address was originated. -> wants to change phase().


Before Writing:
> Have your data, tables of data, images/figures -> Arrange them in order. 
> Do not write intro
> Start with the experimental
> then results and discussion
> do the editing --> make the report into clear and concise english.
> write the conclusions
> then the abstract and acknowledgements
> lastly -> introduction -> answering why the study is done? what is its purpose? Collect relavent 
							background information and put it in the background.
> Producing the references.

READING A PAPER:
> 2-PHASE-> SURVEY -> kEY WORDS & Title -> abstract -> conclusions
> Read tables, figures and captions
> Introduction -> Results + discussion
> experimental SECTIONS (How they did it)

What makes a good paper:
Concise title
Standard Outline
Useful data and results
References -> be sure to include new tech + innovation

GOOD Abstract -> concise summary of report> should explain what make your paper unique, includ significant
				new information. state your conclusion.
				
Explain the methodology

Support conclusions with solid evidence.

DO'S AND DONTS ->>>>>>>>>>>>>>>>>

DO: Simple sentences and use common language. Proof!!! > Show the contribution your paper will make.
DONT: Make grammar or spelling ERRORS. 

What lesson have you learned?
What should the reader understand from your work?
How does your work differ fom the similar papers?
What useful information did you derive form the literature review?
Who is your target audience?

Audience > (Problem): Why did you conduct the project?
			(Solution): What did you contribute to industry knowledge?
			(Value): Why should the audience listen to you?


Introduction => Describe the your contribution
			 => Present nature and scope of the problem investigated.
			 
Results => avoid using redundancy + too mant tables and figures.

Start from conclusions > methodology > results
Ask some else to read the paper > get feedback.


**** Time it take to call functions from blockchain.